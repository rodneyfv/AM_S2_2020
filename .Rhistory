contour(bivn.kde,main=paste("correlação = ",0),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
#par(mar = c(0, 0, 0, 0))
# now plot your results
contour(bivn.kde,main=paste("correlação = ",0),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
#dev.new(width=20, height=5)
#par(mar=c(0.01,0.01,0.01,0.01))
par(resetPar())
#par(mar = c(0, 0, 0, 0))
# now plot your results
contour(bivn.kde,main=paste("correlação = ",0),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
# vetor de correlações que usaremos nas densidades
corre<-c(0,0,-0.9,0.9)
#par(mfrow=c(2,2))
# simulando uma amostra da normal bivariada
bivn <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, corre[1], corre[1], 1), 2))
# estimação da densidade por núcleo
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
# função para sair do modo que divide a tela nos gráficos
resetPar <- function() {
dev.new()
op <- par(no.readonly = TRUE)
dev.off()
op
}
#dev.new(width=20, height=5)
#par(mar=c(0.01,0.01,0.01,0.01))
par(resetPar())
par(mfrow=c(2,2))
#par(mar = c(0, 0, 0, 0))
# now plot your results
contour(bivn.kde,main=paste("correlação = ",0),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
# função para sair do modo que divide a tela nos gráficos
resetPar <- function() {
dev.new()
op <- par(no.readonly = TRUE)
dev.off()
op
}
# vetor de correlações que usaremos nas densidades
corre<-c(0,0,-0.9,0.9)
#par(mfrow=c(2,2))
# simulando uma amostra da normal bivariada
bivn <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, corre[1], corre[1], 1), 2))
# estimação da densidade por núcleo
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
#dev.new(width=20, height=5)
#par(mar=c(0.01,0.01,0.01,0.01))
par(resetPar())
par(mfrow=c(2,2))
#par(mar = c(0, 0, 0, 0))
# gráfico dos resultados
contour(bivn.kde,main=paste("correlação = ",0),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
bivn <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(9, corre[2], corre[2], 9), 2))
# estimação da densidade por núcleo
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
# gráfico dos resultados
contour(bivn.kde,main=paste("correla??o = ",0),cex.axis=1.3,cex.lab=1.3,
cex.main=1.3,xlab="",ylab="")
bivn <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, corre[3], corre[3], 1), 2))
# estimação da densidade por núcleo
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
# gráfico dos resultados
contour(bivn.kde,main=paste("correla??o = ",corre[3]),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
bivn <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, corre[4], corre[4], 1), 2))
# estimação da densidade por núcleo
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
# gráfico dos resultados
contour(bivn.kde, main=paste("correla??o = ",corre[4]),cex.axis=1.3,cex.lab=1.3,cex.main=1.3,xlab="",ylab="")
library(nycflights13)
View(flights)
hist(flights$dep_time)
hist(flights$sched_dep_time)
hist(flights$air_time)
hist(flights$distance)
require(ggplot2)
data("diamonds")
View("diamonds")
View(diamonds)
hist(diamonds$carat)
hist(diamonds$price)
?diamonds
hist(diamonds$x)
hist(diamonds$y)
hist(diamonds$z)
require(tidyverse)
diamonds %>% filter(y<15) %>% hist
class(diamonds)
diamonds %>% select(y) %>% filter(y<15) %>% hist
diamonds %>% select(y) %>% filter(y<15) %>% summarise(n=mean)
diamonds %>% select(y) %>% filter(y<15) %>% with(hist(y))
diamonds %>% select(y) %>% filter(y<15) %>% with(hist(y))
diamonds %>% select(y) %>% filter(y<15) %>% hist(y)
?with
diamonds %>% select(z) %>% filter(z<10) %>% with(hist(z))
diamonds %>% select(x) %>% %>% with(hist(x))
diamonds %>% select(x) %>% with(hist(x))
diamonds %>% select(price) %>% with(hist(price))
diamonds %>% select(x) %>% with(hist(x))
diamonds %>% select(y) %>% filter(y<15) %>% with(hist(y))
diamonds %>% select(z) %>% filter(z<10) %>% with(hist(z))
diamonds %>% select(x) %>% with(shapiro.test(x))
diamonds %>% select(x) %>% with(ks.test(x))
# Bibliotecas necessarias
library(plotrix)
library(plyr)
library(car)
library(mice)
library(xtable)
setwd("/media/rodney/Arquivos/Doutorado/PED/PEDme731/AM_S2_2020/Programas/AM_S2_2020")
diamonds %>% select(x) %>% with(ks.test(scale(x),"pnorm",0,1))
qqPlot(scale(diamonds$x),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",main=inames[j],
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(diamonds$x),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
diamantes <- diamonds %>% filter(y<15 & z<10)
qqPlot(scale(diamantes$x),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(diamantes$y),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(diamantes$z),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
hist(diamantes$y)
hist(diamonds$y)
diamonds %>% select(y) %>% filter(y<10) %>% with(hist(y))
diamonds %>% select(y) %>% filter(y<10 & y>3) %>% with(hist(y))
diamonds %>% select(z) %>% filter(z<10) %>% with(hist(z))
diamonds %>% select(y) %>% filter(y<10 & y>3) %>% with(hist(y))
diamonds %>% select(z) %>% filter(z<10) %>% with(hist(z))
diamonds %>% select(z) %>% filter(z<6 & z>2) %>% with(hist(z))
diamonds %>% select(y) %>% filter(y<10 & y>3) %>% with(hist(y))
diamonds %>% select(x) %>% with(hist(x))
diamonds %>% select(x) %>% filter(x<9 & x>3) %>% with(hist(x))
diamonds %>% select(y) %>% with(hist(y))
diamonds %>% select(z) %>% filter(z<6 & z>2) %>% with(hist(z))
diamantes <- diamonds %>% filter(x<9 & x>3 & y<10 & y>3 & z<6 & z>2)
qqPlot(scale(diamantes$z),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
diamantes <- diamonds %>% filter(cut %in% c("Good","Very Good") ) %>%
filter(x<9 & x>3 & y<10 & y>3 & z<6 & z>2)
diamonds %>% select(x) %>% with(ks.test(scale(x),"pnorm",0,1))
qqPlot(scale(diamantes$z),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(diamantes$x),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(diamantes$y),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
car_body <- read.table("./car_body_data.dat")
head(car_body)
qqPlot(scale(car_body$V1),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(car_body$V2),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(car_body$V3),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(car_body$V4),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(car_body$V5),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
qqPlot(scale(car_body$V6),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",
ylab="quantis da distribuição da distância",cex=1.2)
names(car_body)
i
summary(car_body)
hist(car_body$V5)
apply(car_body,2,mean)
apply(car_body,2,mean)
apply(car_body,2,sd)
apply(car_body,2,min)
apply(car_body,2,max)
par(mfrow=c(3,3))
for(i in 1:6)
{
qqPlot(scale(car_body$V6),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",main=names(car_body)[i],
ylab="quantis da distribuição da distância",cex=1.2)
}
# histrogram das variáveis
par(mfrow=c(3,3))
for(i in 1:6)
{
hist(car_body[,i],main=names(car_body)[i],cex=1.2)
}
# histrogram das variáveis
par(mfrow=c(3,2))
for(i in 1:6)
{
hist(car_body[,i],main=names(car_body)[i],cex=1.2)
}
names(car_body)[i]
for(i in 1:6)
{
hist(car_body[,i],main=paste(names(car_body)[i]),cex=1.2)
}
names(car_body)[i]
paste(names(car_body)[i])
for(i in 1:6)
{
hist(car_body[,i],main=paste(names(car_body)[i]),cex=1.2,xlab="")
}
# gráfico de quantis-quantis
par(mfrow=c(3,2))
# gráfico de quantis-quantis
par(mfrow=c(3,2))
for(i in 1:6)
{
qqPlot(scale(car_body[,i]),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",
xlab="quantis da N(0,1)",main=names(car_body)[i],
ylab="quantis da distribuição da distância",cex=1.2)
}
?mahalanobis
# estimando o vetor de médias e a matriz de covariâncias
vmu <- apply(car_body,2,mean)
vm
vmu
s2 <- cov(car_body)
s2
T2
vmu0 = rep(0,6)
mS2 <- cov(car_body)
T2 = n*t(vmu - vmu0)%*%solve(mS2)%*%(vmu - vmu0)
vmu0 = rep(0,6)
T2 = n*t(vmu - vmu0)%*%solve(mS2)%*%(vmu - vmu0)
vmu - vmu0
t(vmu - vmu0)
# estimando o vetor de médias e a matriz de covariâncias
vmu <- c(apply(car_body,2,mean))
vmu
vmu0 = rep(0,6)
vmu0
t(vmu - vmu0)
t(vmu - vmu0)%*%solve(mS2)
(vmu - vmu0)
t(vmu - vmu0)%*%solve(mS2)%*%(vmu - vmu0)
T2 = n*t(vmu - vmu0)%*%solve(mS2)%*%(vmu - vmu0)
n
#  levando em conta que a matriz de covariâncias é desconhecida,
#  a estatística de teste é calculada a seguir
n = dim(car_body)[1]
n
T2 = n*t(vmu - vmu0)%*%solve(mS2)%*%(vmu - vmu0)
T2
p
p = 6
# usando a relação entre T2 e a distribuição F temos que
Fstat = (n-p)*T2/( (n-1)*p )
Fstat
pf(0.05,df1 = p, df2 = n-p, lower.tail = TRUE)
pf(0.95,df1 = p, df2 = n-p, lower.tail = TRUE)
qf(0.95,df1 = p, df2 = n-p, lower.tail = TRUE)
qf(0.05,df1 = p, df2 = n-p, lower.tail = TRUE)
?qf
qf(0.95,df1 = p, df2 = n-p, lower.tail = TRUE)
# usando a relação entre T2 e a distribuição F temos que
Fstat = (n-p)*T2/( (n-1)*p ); Fstat
qf(0.95,df1 = p, df2 = n-p, lower.tail = TRUE)
# nesse caso, podemos usar a seguinte matriz de contraste
mR = matrix(c(0,0,1,-1,0,0,
0,0,0,-1,0,1),2,6)
mR
# nesse caso, podemos usar a seguinte matriz de contraste
mR = matrix(c(0,0,1,-1,0,0,
0,0,0,-1,0,1),2,6,byrow = TRUE)
mR
# nesse caso, podemos usar a seguinte matriz de contraste
mR = matrix(c(0,0,1,-1,0,0,
0,0,0,-1,0,1,
0,0,0,0,1,0),2,6,byrow = TRUE); mR
# nesse caso, podemos usar a seguinte matriz de contraste
mR = matrix(c(0,0,1,-1,0,0,
0,0,0,-1,0,1,
0,0,0,0,1,0),3,6,byrow = TRUE); mR
rank(mR)
# podemos usar a estatística de teste dada em aula
vY = mR%*%vmu
Fstat = ((n-3)*n/( (n-1)*3 ))*
t(vY - vb)%*%solve(mR%*%mS2%*%t(mR))%*%(vY - vb); Fstat
vb = c(0,0,3/4)  # vetor com as restrições
# nesse caso, podemos usar a seguinte matriz de contraste
mR = matrix(c(0,0,1,-1,0,0,
0,0,0,-1,0,1,
0,0,0,0,1,0),3,6,byrow = TRUE); mR
vb = c(0,0,3/4)  # vetor com as restrições
# podemos usar a estatística de teste dada em aula
vY = mR%*%vmu
Fstat = ((n-3)*n/( (n-1)*3 ))*
t(vY - vb)%*%solve(mR%*%mS2%*%t(mR))%*%(vY - vb); Fstat
qf(0.95,df1 = 3, df2 = n-3, lower.tail = TRUE)
?qqPlot
library(car)
library(xtable)
#
dados<-read.table(file=".\Dados\\Amitripilina.txt")
#
dados<-read.table(file=".\Dados\Amitripilina.txt")
?read.table
#
dados<-read.table(file=".\Dados\Amitripilina.txt", encoding = "windows-1252")
#
dados<-read.table(file="./Dados/Amitripilina.txt", encoding = "windows-1252")
colnames(dados) <- c("Tot","Ami","Gen","Amt","Pr","Diap","Qrs")
dadosdf <- data.frame(dados)
dadosdf
#xtable(dados)
#
par(mfrow=c(1,1))
plot(dadosdf$Ami,dadosdf$Tot,pch=19,cex.axis=1.2,cex.lab=1.2,cex=1.2,xlab="Ami",ylab="Tot")
cor(dadosdf$Ami,dadosdf$Tot)
#
par(mfrow=c(1,2))
plot(dadosdf$Amt,dadosdf$Tot,pch=19,cex.axis=1.2,cex.lab=1.2,cex=1.2,xlab="Amt",ylab="Tot")
plot(dadosdf$Amt,dadosdf$Ami,pch=19,cex.axis=1.2,cex.lab=1.2,cex=1.2,xlab="Amt",ylab="Ami")
# A função lm, no caso multivariado, trabalha com o vec(B) e não com o Vec(B')
fit.model<-lm(cbind(dadosdf$Tot,dadosdf$Ami)~Amt,data=dadosdf)
summary(fit.model)
m.ajuste<-fit.manova<-manova(cbind(dadosdf$Tot,dadosdf$Ami)~Amt,data=dadosdf)
summary.manova(m.ajuste,test="Wilks")
summary.manova(m.ajuste,test="Pillai")
summary.manova(m.ajuste,test="Hotelling-Lawley")
summary.manova(m.ajuste,test="Roy")
aux<-summary.aov(m.ajuste)
aux
#
# Estimando a matriz Sigma
mX <- as.matrix(model.matrix(fit.manova))
n<-nrow(mX)
eq<-ncol(mX)
mY <- cbind(dadosdf$Tot,dadosdf$Ami)
mB <- solve(t(mX)%*%mX)%*%t(mX)%*%mY
mSigma <- (t(mY-mX%*%mB)%*%(mY-mX%*%mB))/(n-eq)
# Estimativa dos parâmetros
vbeta<- c(coef(m.ajuste))
mcovbeta <- vcov(m.ajuste)
epbeta <- as.vector(sqrt(diag(mcovbeta)))
#
quantt <- qt(0.975,df=17-2)
mresult <- cbind(vbeta,epbeta,vbeta-quantt*epbeta,vbeta+quantt*epbeta,vbeta/epbeta,2*(1-pt(vbeta/epbeta,df=17-2)))
xtable(mresult)
# Valores preditos (usando a aproximação pela normal)
# Variável Tot
par(mfrow=c(1,2))
m.fitted <- fitted(fit.model)
plot(dadosdf$Amt,dadosdf$Tot,pch=19,cex.axis=1.2,cex.lab=1.2,cex=1.2,xlab="amt",ylab="Tot",ylim=c(000,4000))
lines(dadosdf$Amt,m.fitted[,1],col=1,type="l",lwd=2,pch=19,cex.axis=1.2)
# média
epmupred <- sqrt(mcovbeta[1,1] + mcovbeta[2,2]*(sort(dadosdf$Amt^2)) + mcovbeta[1,2])
liicmupred <- sort(m.fitted[,1]) - 1.96*epmupred
liscmupred <- sort(m.fitted[,1]) + 1.96*epmupred
lines(sort(dadosdf$Amt),liicmupred,col=2,type="l",lwd=2,lty=2,pch=19,cex.axis=1.2)
lines(sort(dadosdf$Amt),liscmupred,col=2,type="l",lwd=2,lty=2,pch=19,cex.axis=1.2)
# uma única observação
epY <- sqrt(mcovbeta[1,1] + mcovbeta[2,2]*(sort(dadosdf$Amt^2)) + mcovbeta[1,2]+diag(mSigma)[1])
liicY <- sort(m.fitted[,1]) - 1.96*epY
liscY <- sort(m.fitted[,1]) + 1.96*epY
lines(sort(dadosdf$Amt),liicY,col=3,type="l",lwd=2,lty=2,pch=19,cex.axis=1.2)
lines(sort(dadosdf$Amt),liscY,col=3,type="l",lwd=2,lty=2,pch=19,cex.axis=1.2)
legend(10,4200,col=c(1,2,3),lwd=c(2,2,2),legend=c("Reta predita","IC para média","IP para uma única observação"),bty="n",cex=1.2)
#
plot(dadosdf$Amt,dadosdf$Ami,pch=19,cex.axis=1.2,cex.lab=1.2,cex=1.2,xlab="amt",ylab="Ami",ylim=c(000,4000))
lines(dadosdf$Amt,m.fitted[,2],col=1,type="l",lwd=2,pch=19,cex.axis=1.2)
# Variável Ami
# média
epmupred <- sqrt(mcovbeta[3,3] + mcovbeta[4,4]*(sort(dadosdf$Amt^2)) + mcovbeta[3,4])
liicmupred <- sort(m.fitted[,2]) - 1.96*epmupred
# Variável Ami
# média
epmupred <- sqrt(mcovbeta[3,3] + mcovbeta[4,4]*(sort(dadosdf$Amt^2)) + mcovbeta[3,4])
mcovbeta[3,3]
mcovbeta
vcov(m.ajuste)
m.ajuste
# Resíduos univariados
mY <- as.matrix(cbind(dadosdf$Tot,dadosdf$Ami))
mresult<-m.ajuste
typeresid <- "univariate"
wplot <- "diagnostics"
#
# Tot
var<-1
gen.graf.resid(mY,mresult,var,typeresid,wplot)
source("./Diag Multivariate Linear Models ME 731 2S 2020.R", encoding = "windows-1252")
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Resíduos univariados
mY <- as.matrix(cbind(dadosdf$Tot,dadosdf$Ami))
mresult<-m.ajuste
typeresid <- "univariate"
wplot <- "diagnostics"
#
# Tot
var<-1
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Ami
var<-2
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Zoom nos envelopes
wplot <- "envelope"
#
# Tot
var<-1
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Ami
var<-2
gen.graf.resid(mY,mresult,var,typeresid,wplot)
typeresid <- "multivariate"
wplot <- "diagnostics"
#
# Tot
var<-1
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Ami
var<-2
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Zoom nos envelopes
wplot <- "envelope"
#
# Tot
var<-1
gen.graf.resid(mY,mresult,var,typeresid,wplot)
# Ami
var<-2
gen.graf.resid(mY,mresult,var,typeresid,wplot)
gen.graf.resid.quad.form(mY,mresult)
# Testanto se os coeficientes angulares são iguais
source("./MANOVA_Multivariada_ME_731_2S_2020.R")
#
# Lembrando que para esta função trabalhamos
m.C <-cbind(0,1)
m.U <- rbind(1,-1)
m.M <-0
TesteF.CBU.M(fit.manova,mSigma,2,2,m.C,m.U,m.M)
# Verificando os resultado
mX <- as.matrix(model.matrix(fit.manova))
n<-nrow(mX)
eq<-ncol(mX)
mY <- cbind(dadosdf$Tot,dadosdf$Ami)
mB <- solve(t(mX)%*%mX)%*%t(mX)%*%mY
vbeta <- c(t(mB))
mSigma <- (t(mY-mX%*%mB)%*%(mY-mX%*%mB))/(n-eq)
mcovbeta <- kronecker(solve(t(mX)%*%mX),mSigma)
# Análise residual
# Resíduos ordinários
m.residuo <- m.ajuste$residuals
m.X <-as.matrix(model.matrix(m.ajuste))
auxres <- diag((diag(n) - m.X%*%solve(t(m.X)%*%m.X)%*%t(m.X)))
m.residuo <- m.residuo/(sqrt((matrix(auxres,17,2))%*%diag(diag(mSigma))))
m.ajustado <- fitted.values(m.ajuste)
#
# Tot
par(mfrow =c(2,2))
plot(m.residuo[,1],ylim=c(min(-3,min(m.residuo[,1])),max(3,max(m.residuo[,1]))),xlab="índice",ylab="resíduo studentizado")
abline(-2,0,lty=2)
abline(2,0,lty=2)
abline(0,0,lty=2)
#
plot(m.ajustado[,1],m.residuo[,1],ylim=c(min(-3,min(m.residuo[,1])),max(3,max(m.residuo[,1]))),xlab="valor ajustado",ylab="resíduo studentizado")
abline(-2,0,lty=2)
abline(2,0,lty=2)
abline(0,0,lty=2)
#
hist(m.residuo[,1],probability=TRUE,xlab="resíduo studentizado",main="",ylab="densidade")
#
qqPlot((m.residuo[,1]),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",xlab="quantil da N(0,1)",ylab=paste("quantil da distribuição do resíduo studentizado"),cex=1.2,id.cex=1.2)
#
# Ami
par(mfrow =c(2,2))
#
qqPlot((m.residuo[,1]),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",xlab="quantil da N(0,1)",ylab=paste("quantil da distribuição do resíduo studentizado"),cex=1.2)
#
# Ami
par(mfrow =c(2,2))
plot(m.residuo[,2],ylim=c(min(-3,min(m.residuo[,2])),max(3,max(m.residuo[,2]))),xlab="índice",ylab="resíduo studentizado")
abline(-2,0,lty=2)
abline(2,0,lty=2)
abline(0,0,lty=2)
#
plot(m.ajustado[,2],m.residuo[,2],ylim=c(min(-3,min(m.residuo[,2])),max(3,max(m.residuo[,2]))),xlab="valor ajustado",ylab="resíduo studentizado")
abline(-2,0,lty=2)
abline(2,0,lty=2)
abline(0,0,lty=2)
#
hist(m.residuo[,2],probability=TRUE,xlab="resíduo studentizado",main="",ylab="densidade")
#
qqPlot((m.residuo[,2]),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",xlab="quantil da N(0,1)",ylab=paste("quantil da distribuição do resíduo studentizado"),cex=1.2,id.cex=1.2)
#
qqPlot((m.residuo[,2]),dist="norm",mean=0,sd=1,col.lines=1,grid="FALSE",xlab="quantil da N(0,1)",ylab=paste("quantil da distribuição do resíduo studentizado"),cex=1.2)
# bibliotecas necessárias
library(car)
library(tidyverse)
# lendo os dados
practice_delay <- read.table("./Dados/practice_delay.dat",header = TRUE)
# bibliotecas necessárias
library(car)
library(tidyverse)
# lendo os dados
feijao_dados <- read.table("./Dados/feijao_data.dat",header = TRUE)
source("./MANOVA_Multivariada_ME_731_2S_2020.R")
source("./Diag Multivariate Linear Models ME 731 2S 2020.R",
encoding = "windows-1252")
